\chapter{Other}
\section{Gurson Model}
\subsection{Theory}
\subsection{Formulation}
\subsection{Implementation}
\begin{cppcode}
int NonlinearGurson::update_trial_status(const vec& t_strain) {
    incre_strain = (trial_strain = t_strain) - current_strain;

    if(norm(incre_strain) <= tolerance) return SUANPAN_SUCCESS;

    trial_stress = current_stress + (trial_stiffness = initial_stiffness) * incre_strain;

    trial_history = current_history;
    auto& pe = trial_history(0); // equivalent plastic strain
    auto& f = trial_history(1);  // volume fraction
    const auto& current_pe = current_history(0);
    const auto& current_f = current_history(1);

    auto trial_s = tensor::dev(trial_stress);                            // trial deviatoric stress
    const auto trial_q = sqrt_three_two * tensor::stress::norm(trial_s); // trial von Mises stress
    const auto trial_p = tensor::mean3(trial_stress);                    // trial hydrostatic stress
    auto p = trial_p;                                                    // hydrostatic stress

    mat jacobian(4, 4);
    vec incre, residual(4);
    auto gamma = 0.;
    double denom;

    unsigned counter = 0;
    while(true) {
        if(max_iteration == ++counter) {
            suanpan_error("NonlinearGurson cannot converge within %u iterations.\n", max_iteration);
            return SUANPAN_FAIL;
        }

        const auto hardening = compute_hardening(pe);
        const auto &k = hardening(0), &dk = hardening(1);
        const auto hyper_term = 1.5 * q2 * p / k;
        const auto cosh_term = cosh(hyper_term);
        const auto sinh_term = sinh(hyper_term);
        const auto q = trial_q / (denom = 1. + six_shear * gamma);
        const auto an = para_b * exp(-.5 * pow((pe - en) / sn, 2.));
        const auto para_d = para_a * sinh_term;

        const auto diff_pe = pe - current_pe, diff_p = p - trial_p;

        residual(0) = q * q + k * k * (f * q1 * (2. * cosh_term - q1 * f) - 1.);

        if(1 == counter && residual(0) < 0.) return SUANPAN_SUCCESS;

        residual(1) = (1. - f) * k * diff_pe - 2. * gamma * q * q + p * diff_p / bulk;
        residual(2) = f - current_f + (1. - f) * diff_p / bulk - an * diff_pe;
        residual(3) = diff_p + para_a * gamma * f * k * sinh_term;

        jacobian(0, 0) = -2. * six_shear / denom * q * q;
        jacobian(0, 1) = (f * (4. * q1 * k * cosh_term - para_d / bulk * p) - 2. * k * (q1 * q1 * f * f + 1.)) * dk;
        jacobian(0, 2) = 2. * k * k * q1 * (cosh_term - q1 * f);
        jacobian(0, 3) = para_d / bulk * f * k;
        jacobian(1, 0) = 2. * q * q * (six_shear * gamma - 1.) / denom;
        jacobian(1, 1) = (1. - f) * (dk * diff_pe + k);
        jacobian(1, 2) = -k * diff_pe;
        jacobian(1, 3) = (p + diff_p) / bulk;
        jacobian(2, 0) = 0.;
        jacobian(2, 1) = an / sn / sn * (pe - en) * diff_pe - an;
        jacobian(2, 2) = 1. - diff_p / bulk;
        jacobian(2, 3) = (1. - f) / bulk;
        jacobian(3, 0) = para_d * f * k;
        jacobian(3, 1) = para_a * gamma * f * (sinh_term - hyper_term * cosh_term) * dk;
        jacobian(3, 2) = para_d * gamma * k;
        jacobian(3, 3) = 1. + 1.5 * para_a * q2 * gamma * f * cosh_term;

        if(!solve(incre, jacobian, residual)) return SUANPAN_FAIL;

        const auto error = norm(residual);
        suanpan_debug("NonlinearGurson local iteration error: %.5E.\n", error);
        if(error <= tolerance || norm(incre) <= tolerance) break;

        gamma -= incre(0);
        pe -= incre(1);
        f -= incre(2);
        p -= incre(3);

        f = std::min(std::max(f, 0.), 1.); // avoid overshoot
    }

    trial_s /= denom;

    mat left, right(4, 6);

    right.row(0) = -six_shear / denom * trial_s.t();
    right.row(1) = -2. * gamma * right.row(0) + p * tensor::unit_tensor2.t();
    right.row(2) = (1. - f) * tensor::unit_tensor2.t();
    right.row(3) = bulk * tensor::unit_tensor2.t();

    if(!solve(left, jacobian, right)) return SUANPAN_FAIL;

    trial_stress = trial_s + p * tensor::unit_tensor2;

    trial_stiffness = six_shear / denom / 3. * unit_dev_tensor - six_shear / denom * trial_s * left.row(0) + tensor::unit_tensor2 * left.row(3);

    return SUANPAN_SUCCESS;
}
\end{cppcode}
\section{NM Material}
The traditional constitutive theory is, as can be seen in previous models, often applied to strain and stress at each integration point. Similar concepts can be applied to other quantities such as cross section deformation and resultant.

An example of beam section constitutive models based on the generalised plasticity theory \cite{Auricchio1994} is presented.
\subsection{Theory}
\subsubsection{Kinematics and Elasticity}
For a 3D section involving axial and flexural deformation of a two--node beam element with its chord aligned with the $x$-axis, the sectional deformation can be arranged into a vector such that
\begin{gather}
\mb{v}=\begin{bmatrix}
\varepsilon&\chi_{z,i}&\chi_{z,j}&\chi_{y,i}&\chi_{y,j}
\end{bmatrix}^\mT,
\end{gather}
where $\varepsilon$ is the axial strain while $\chi=\theta/L$ is the section rotation over the length of the element, subscripts $\left(\cdot\right)_i$ and $\left(\cdot\right)_j$ denote two nodes, $\left(\cdot\right)_z$ and $\left(\cdot\right)_y$ denote strong and weak axis, respectively.

For each end, the nodal local deformation can be extracted as
\begin{gather}
\mb{v}_i=\begin{bmatrix}
\varepsilon\\\chi_{z,i}\\\chi_{y,i}
\end{bmatrix}=\begin{bmatrix}
1&\cdot&\cdot&\cdot&\cdot\\
\cdot&1&\cdot&\cdot&\cdot\\
\cdot&\cdot&\cdot&1&\cdot
\end{bmatrix}\mb{v}=\mb{T}_i\mb{v},\\
\mb{v}_j=\begin{bmatrix}
\varepsilon\\\chi_{z,j}\\\chi_{y,j}
\end{bmatrix}=\begin{bmatrix}
1&\cdot&\cdot&\cdot&\cdot\\
\cdot&\cdot&1&\cdot&\cdot\\
\cdot&\cdot&\cdot&\cdot&1
\end{bmatrix}\mb{v}=\mb{T}_j\mb{v},
\end{gather}

Accordingly, the section resistance can be defined as
\begin{gather}
\mb{q}=\begin{bmatrix}
P&M_{z,i}&M_{z,j}&M_{y,i}&M_{y,j}
\end{bmatrix}^\mT,
\end{gather}
where $P$ is used to denote axial force while $M$ is used to denote end moment.

The same transformation matrices can be applied to obtain nodal local resistance.
\begin{gather}
\mb{q}_i=\mb{T}_i\mb{q},\qquad
\mb{q}_j=\mb{T}_j\mb{q}.
\end{gather}

According to convention, the elastic response can be defined as
\begin{gather}
\mb{q}=\mb{E}\left(\mb{v}-\mb{v}^p\right),\qquad\mb{E}=\begin{bmatrix}
EA&\cdot&\cdot&\cdot&\cdot\\
\cdot&4EI_z&2EI_z&\cdot&\cdot\\
\cdot&2EI_z&4EI_z&\cdot&\cdot\\
\cdot&\cdot&\cdot&4EI_y&2EI_y\\
\cdot&\cdot&\cdot&2EI_y&4EI_y
\end{bmatrix}.
\end{gather}
\subsubsection{Yield Function}
For each node, if the nodal resistance is bounded by the yield surface, it is elastic.
\begin{gather}
f_\aleph=\Phi_\aleph-q^y_\aleph,
\end{gather}
where $\Phi_\aleph=\Phi_\aleph\left(\mb{s}_\aleph\right)$ is the $N$-$M$ interaction surface based on the shifted resistance $\mb{s}_\aleph=\mb{q}_\aleph-\bbeta_\aleph$, while
\begin{gather}
q^y_\aleph=c+H\alpha_\aleph
\end{gather}
is the equivalent yield measure which can evolve to account for isotropic hardening. The parameter $H$ controls isotropic hardening, $\alpha_\aleph$ is the equivalent plastic strain, $\bbeta_\aleph$ is similar to the concept of back stress, here back resistance that defines the centre of interaction surface. The subscript $\left(\cdot\right)_\aleph$ denotes either $\left(\cdot\right)_i$ or $\left(\cdot\right)_j$. If $\alpha_\aleph=0$, then $q^y_\aleph=c$. From which it is quite clear that $c$ characterises the initial size of yield surface, thus cannot be negative.

It is worth noting that plasticity can develop at either end, while two ends are linked with each other due to the shared axial force.
\subsubsection{Flow Rule}
The associated flow rule is adopted. The evolution of plastic deformation $\mb{v}^p_\aleph$ shall be linked to $\pdfrac{\Phi_\aleph}{\mb{q}_\aleph}$. By denoting $\mb{\zeta}_\aleph=\pdfrac{\Phi_\aleph}{\mb{q}_\aleph}$, one can obtain
\begin{gather}
\dot{\mb{v}^p_\aleph}=\gamma_\aleph\mb{\zeta}_\aleph.
\end{gather}
\subsubsection{Hardening Law}
For isotropic hardening, $\dot{\alpha_\aleph}$ shall be related to some scalar measure of plastic deformation $\dot{\mb{v}^p_\aleph}$. The simplest one would be
\begin{gather}
\dot{\alpha_\aleph}=\norm{\dot{\mb{v}^p_\aleph}}=\gamma_\aleph\norm{\mb{\zeta}_\aleph}.
\end{gather}

For kinematic hardening,
\begin{gather}
\dot{\bbeta}=K\mb{E}\sum\gamma_\aleph\mb{\zeta}_\aleph.
\end{gather}

According to the above definition, $H$ and $K$ are more like two hardening ratios.
\subsection{Formulation}
\subsubsection{Elastic Loading/Unloading}
By freezing plasticity, one can compute the trial state as
\begin{gather}
\mb{q}^\text{trial}=\mb{q}_n+\mb{E}\left(\mb{v}_{n+1}-\mb{v}_n\right),
\end{gather}
and
\begin{gather}
f^\text{trial}_\aleph=\Phi_\aleph^\text{trial}-q^y_{\aleph,n},
\end{gather}
with $\Phi_\aleph^\text{trial}=\Phi_\aleph\left(\bs^\text{trial}_\aleph\right)$ in which $\bs^\text{trial}_\aleph=\mb{q}_\aleph^\text{trial}-\bbeta_{\aleph,n}$.

If both $f^\text{trial}_i$ and $f^\text{trial}_j$ are smaller than zero, indicating both ends are undergoing elastic loading/unloading.
\subsubsection{Plasticity Evolution}
For resistance and back resistance, one can obtain
\begin{gather}
\mb{q}_{n+1}=\mb{q}^\text{trial}-\mb{E}\dot{\mb{v}^p}=\mb{q}^\text{trial}-\mb{E}\sum\gamma_\aleph\mb{\zeta}_{\aleph,n+1},\\
\bbeta_{n+1}=\bbeta_{n}+K\mb{E}\sum\gamma_\aleph{}\mb{\zeta}_{\aleph,n+1}.
\end{gather}

Given that $\Phi_\aleph$ can be arbitrarily defined, there is no guarantee to have coaxiality between two vectors.
\subsubsection{Local Residual}
We take $\mb{x}=\begin{bmatrix}
\mb{q}_{n+1}&\bbeta_{n+1}&\gamma_i&\gamma_j
\end{bmatrix}$ as the local variable, the local residual is
\begin{gather}
\mb{R}=\left\{
\begin{array}{l}
\mb{q}_{n+1}-\mb{q}^\text{trial}+\mb{E}\sum\gamma_\aleph\mb{\zeta}_{\aleph,n+1},\\[4mm]
\bbeta_{n+1}-\bbeta_{n}-K\mb{E}\sum\gamma_\aleph{}\mb{\zeta}_{\aleph,n+1},\\[4mm]
\Phi_{i,n+1}-q^y_{i,n+1},\\[4mm]
\Phi_{j,n+1}-q^y_{j,n+1}.
\end{array}
\right.
\end{gather}

The most distinctive difference that can be spotted in the activations of $\gamma_i$ and $\gamma_j$ are independent from each other. Physically, plasticity evolution can be activated when either end yields, or both yield. Thus, each end shall be handled separately.

The implementation is not complicated with the subview of the matrix can be extracted.

The consistent tangent operator can be easily extracted at local equilibrium as only the first equation contains non-zero partial derivative with regard to $\mb{v}_{n+1}$.
\subsection{Implementation}