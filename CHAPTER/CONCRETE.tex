\chapter{Concrete}
\section{Concrete Damage Plasticity Model}
In this section, the concrete damage plasticity model proposed by \cite{Lee1998} is presented. A slight different version (with Lode angle dependency and others) is implemented in ABAQUS.

The CDP model follows Lemaitre's damage theory \cite{Lemaitre1985} and is developed under the assumption of isotropic damage. Accordingly, the final stress $\bsigma$ can be expressed as the product of the effective stress $\bbsigma$ and some function of damage measure.
\begin{gather}
\bsigma=h\left(d_t,d_c\right)\bbsigma,
\end{gather}
where $h\left(d_t,d_c\right)$ is a function of two damage variables $d_t$ and $d_c$, which depend on some internal history variables.

The effective part $\bbsigma$ fully resembles the conventional plasticity. Thus $h\left(d_t,d_c\right)$ and $\bbsigma$ can be handled in a relatively independent manner.
\subsection{Plasticity Theory}
\subsubsection{Yield Function}
The yield function is defined as
\begin{gather}
f=\alpha\bar{I}_1+\sqrt{\dfrac{3}{2}}\norm{\bar{\bs}}+\beta\left\langle\hat{\sigma}_1\right\rangle-\left(1-\alpha\right)c_c,
\end{gather}
with $\bar{I}_1=\tr{\bbsigma}$ is the first invariant of effective stress tensor $\bbsigma$, $\hat{\sigma}_1$ is the major effective principal stress, $c_c=-\bar{f}_c$ denotes cohesion and $\beta=\dfrac{\bar{f}_c}{\bar{f}_t}(\alpha-1)-(\alpha+1)$. The effective backbone stresses (both positive) $\bar{f}_c$ and $\bar{f}_t$ will be defined later.
\subsubsection{Flow Rule}
The flow potential $g$ is chosen to be
\begin{gather}
g=\sqrt{2\bar{J}_2}+\alpha_p\bar{I}_1=\norm{\bar{\bs}}+\tr{\alpha_p\bbsigma}.
\end{gather}
The flow rule is accordingly defined as
\begin{gather}
\dot{\bvarepsilon^p}=\gamma\pdfrac{g}{\bbsigma}=\gamma\left(\dfrac{\bar{\bs}}{\norm{\bar{\bs}}}+\alpha_p\mb{1}\right)=\gamma\left(\bn+\alpha_p\mb{1}\right).
\end{gather}
In deviatoric and spherical components,
\begin{gather}
\dot{\bvarepsilon^{d,p}}=\gamma\bn,\quad\dot{\varepsilon^{v,p}}=\gamma3\alpha_p.
\end{gather}

Noting that
\begin{gather}
\bar{\bs}=\bar{\bs}^\text{trial}-2G\dot{\bvarepsilon^{d,p}}=\bar{\bs}^\text{trial}-\gamma2G\bn,\\
\bar{p}=\bar{p}^\text{trial}-K\dot{\varepsilon^{v,p}}=\bar{p}^\text{trial}-\gamma3K\alpha_p,
\end{gather}
equivalently,
\begin{gather}
\norm{\bar{\bs}}+\gamma2G=\norm{\bar{\bs}^\text{trial}},\\
\bar{I}_1+\gamma9K\alpha_p=\bar{I}_1^\text{trial}.
\end{gather}
Furthermore, $\bs$ and $\bs^\text{trial}$ are coaxial, thus,
\begin{gather}
\dfrac{\bar{\bs}}{\norm{\bar{\bs}}}=\dfrac{\bar{\bs}^\text{trial}}{\norm{\bar{\bs}^\text{trial}}}\equiv{}\bn.
\end{gather}
It simply means the flow direction is fixed for all iterations in each sub-step. And due to the coaxiality, $\bar{\bs}$ and $\bar{\bs}^\text{trial}$ share the same eigen space. More importantly, the eigenvectors remain constant for each iteration. Thus,
\begin{gather}
\dfrac{\bar{\bs}}{\norm{\bar{\bs}}}=\dfrac{\bar{\bs}^\text{trial}}{\norm{\bar{\bs}^\text{trial}}},\qquad
\dfrac{\hat{\bs}}{\norm{\hat{\bs}}}=\dfrac{\hat{\bs}^\text{trial}}{\norm{\hat{\bs}^\text{trial}}},
\end{gather}
where $\hat{\bs}$ denotes the principal stress tensor of the deviatoric stress tensor $\bar{\bs}$. As the yield function $f$ can be equivalently expressed with the principal stresses, in the following derivation, $\hat{\bn}$ is used to represent the unit principal deviatoric stress which has three components. The transformation matrix $\mb{T}$ is defined as
\begin{gather}
\underbrace{\hat{\bsigma}}_\text{\numproduct{3x1}}=\underbrace{\mb{T}}_\text{\numproduct{3x6}}\underbrace{\bbsigma}_\text{\numproduct{6x1}},\qquad
\underbrace{\hat{\bs}}_\text{\numproduct{3x1}}=\underbrace{\mb{T}}_\text{\numproduct{3x6}}\underbrace{\bar{\bs}}_\text{\numproduct{6x1}},
\end{gather}
and can be formulated from eigenanalysis.
\subsubsection{Hardening Law}
Since concrete shows different behaviour under compression and tension, the subscript $\left(\cdot\right)_\aleph$ is used to denoted either tension $\left(\cdot\right)_t$ or compression $\left(\cdot\right)_c$.

Internal hardening parameters $\kappa_\aleph$ shall satisfy the following expression,
\begin{gather}
\dot{\kappa_\aleph}=\gamma{}H_\aleph,
\end{gather}
where $H_\aleph$ defines the hardening law. Different $H_\aleph$ shall be used for compression/tension.
\begin{gather}
H_t=r\dfrac{f_t}{g_t}\left(\hat{n}_1+\alpha_p\right),\\
H_c=\left(1-r\right)\dfrac{f_c}{g_c}\left(\hat{n}_3+\alpha_p\right).
\end{gather}
In which $\hat{n}_1$ and $\hat{n}_3$ denotes the maximum and minimum components in $\hat{\bn}$ and $r$ is a scalar valued function of the effective principal stress. In the original model, it is defined as
\begin{gather}
r\left(\hat{\bsigma}\right)=\dfrac{\left\langle\hat{\sigma}_1\right\rangle+\left\langle\hat{\sigma}_2\right\rangle+\left\langle\hat{\sigma}_3\right\rangle}{\abs{\hat{\sigma}_1}+\abs{\hat{\sigma}_2}+\abs{\hat{\sigma}_3}}.
\end{gather}
The purpose of $r$ is to characterise the proportion of tension in a multiaxial loading case.
\subsubsection{Backbone Curve}
The backbone curve $f_\aleph$ is related to the internal parameter $\kappa_\aleph$.
\begin{gather*}
f_\aleph=f_{\aleph,0}\sqrt{\phi_\aleph}\Phi_\aleph,
\end{gather*}
with
\begin{gather*}
\phi_\aleph=1+a_\aleph\left(2+a_\aleph\right)\kappa_\aleph,\qquad
\Phi_\aleph=\dfrac{1+a_\aleph-\sqrt{\phi_\aleph}}{a_\aleph}.
\end{gather*}

The effective counterpart $\bar{f}_\aleph$ is defined as
\begin{gather*}
\bar{f}_\aleph=\dfrac{f_\aleph}{1-d_\aleph}=f_{\aleph,0}\sqrt{\phi_\aleph}\Phi_\aleph^{1-c_\aleph/b_\aleph},
\end{gather*}
with
\begin{gather*}
d_\aleph=1-\Phi_\aleph^{c_\aleph/b_\aleph}.
\end{gather*}

In general, the backbone curve can be customised. The main algorithm has no interested in how the backbone curve is computed, only $f_\aleph$, $\bar{f}_\aleph$ and $d_\aleph$ and their derivatives with regard to $\kappa_\aleph$ need to be provided. The exponential form adopted in the original model may encounter some numerical difficulties, which in the author's opinion is not ideal. One can always choose another form, such as providing those quantities in a tabulated fashion. This is also what ABAQUS offers.
\subsection{Damage Theory}
The damage measure takes the form
\begin{gather}
h\left(d_t,d_c\right)=\left(1-d_c\right)\left(1-sd_t\right)
\end{gather}
with $s=s_0+\left(1-s_0\right)r$ is the recovery factor.
\subsection{Plasticity Formulation}
The CDP model is driven by three quantities $\kappa_t$, $\kappa_c$ and $\bvarepsilon^p$. The governing equations are listed as follows.
\begin{table}[ht]
\centering
\begin{tabular}{rl}
\toprule
Yield Function&$f=\alpha\bar{I}_1+\sqrt{\dfrac{3}{2}}\norm{\bar{\bs}}+\beta\left\langle\hat{\sigma}_1\right\rangle-\left(1-\alpha\right)c_c$\\
Flow Rule&$\dot{\bvarepsilon^p}=\gamma\left(\dfrac{\bar{\bs}}{\norm{\bar{\bs}}}+\alpha_p\mb{1}\right)$\\
Hardening Law&$\dot{\kappa_\aleph}=\gamma{}H_\aleph$\\
\bottomrule
\end{tabular}
\end{table}
\subsubsection{Elastic Loading/Unloading}
Assuming elastic loading/unloading, the trial state of the effective part can be computed as done in other plasticity models.
\begin{gather}
\bbsigma^\text{trial}=\mb{D}:\left(\bvarepsilon_{n+1}-\bvarepsilon^p_n\right).
\end{gather}
Then by performing eigenanalysis, $\hat{\bsigma}^\text{trial}$ can be computed. The trial yield function is
\begin{gather}\label{eq:cdp_tf}
f^\text{trial}=\alpha\bar{I}_1^\text{trial}+\sqrt{\dfrac{3}{2}}\norm{\bar{\bs}^\text{trial}}+\beta\left\langle\hat{\sigma}_1^\text{trial}\right\rangle-\left(1-\alpha\right)c_c,
\end{gather}
with $\beta$ and $c_c$ computed by using $\kappa_{t,n}$ and $\kappa_{c,n}$. If $f^\text{trial}<0$, indicating elastic loading/unloading, then $\bbsigma_{n+1}=\bbsigma^\text{trial}$, the final stress is simply
\begin{gather}
\bsigma_{n+1}=\left(1-d_{c,n}\right)\left(1-sd_{t,n}\right)\bbsigma^\text{trial}.
\end{gather}

The corresponding tangent stiffness is then
\begin{gather}\label{eq:cdp_ed}
\begin{split}
\pdfrac{\bsigma_{n+1}}{\bvarepsilon_{n+1}}&=\pdfrac{\bsigma_{n+1}}{\bbsigma_{n+1}}:\pdfrac{\bbsigma_{n+1}}{\bvarepsilon_{n+1}}\\
&=\left(1-d_{c,n}\right)d_{t,n}\left(s_0-1\right)\bbsigma^\text{trial}\otimes\ddfrac{r}{\bbsigma_{n+1}}:\mb{D}+\left(1-d_{c,n}\right)\left(1-sd_{t,n}\right)\mb{D}\\
&=\left(1-d_{c,n}\right)\left(d_{t,n}\left(s_0-1\right)\bbsigma^\text{trial}\otimes\ddfrac{r}{\bbsigma_{n+1}}+\left(1-sd_{t,n}\right)\mathbb{I}\right):\mb{D}.
\end{split}
\end{gather}
\subsubsection{Plasticity Evolution}
The yield function and the damage evolutions are three local equations shall be satisfied.
\begin{gather}\label{eq:cdp_r}
\mb{R}=\left\{
\begin{array}{l}
\alpha\bar{I}_1+\sqrt{\dfrac{3}{2}}\norm{\bar{\bs}^\text{trial}}-\gamma\sqrt{6}G+\beta\left\langle\bar{\sigma}_1^\text{trial}-\gamma\left(2G\hat{n}_1+3K\alpha_p\right)\right\rangle+\left(1-\alpha\right)\bar{f}_c,\\[4mm]
\kappa_{t,n}+\gamma{}r\dfrac{f_t}{g_t}\left(\hat{n}_1+\alpha_p\right)-\kappa_t,\\[4mm]
\kappa_{c,n}+\gamma\left(1-r\right)\dfrac{f_c}{g_c}\left(\hat{n}_3+\alpha_p\right)-\kappa_c.
\end{array}
\right.
\end{gather}

By choosing $\mb{x}=\begin{bmatrix}
\gamma&\kappa_t&\kappa_c
\end{bmatrix}^\mT$ as the independent variables and assuming $\hat{\bn}=\dfrac{\hat{\bs}^\text{trial}}{\norm{\hat{\bs}^\text{trial}}}$ that is a function of $\bvarepsilon_{n+1}$ only thus does not contain $\gamma$, the Jacobian can be computed as
\begin{footnotesize}
\begin{gather}\label{eq:cdp_dr}
\mb{J}=\begin{bmatrix}
-9K\alpha\alpha_p-\sqrt{6}G-\beta\left(2G\hat{n}_1+3K\alpha_p\right)H\left(\hat{\sigma}_1\right)&\left\langle\hat{\sigma}_1\right\rangle\pdfrac{\beta}{\kappa_t}&\left(1-\alpha\right)\bar{f}_c'+\left\langle\hat{\sigma}_1\right\rangle\pdfrac{\beta}{\kappa_c}\\[4mm]
f_t\dfrac{\hat{n}_1+\alpha_p}{g_t}\left(r+\gamma\pdfrac{r}{\gamma}\right)&\gamma{}r\dfrac{\hat{n}_1+\alpha_p}{g_t}f_t'-1&\cdot\\[4mm]
f_c\dfrac{\hat{n}_3+\alpha_p}{g_c}\left(1-r-\gamma\pdfrac{r}{\gamma}\right)&\cdot&\gamma\left(1-r\right)\dfrac{\hat{n}_3+\alpha_p}{g_c}f_c'-1
\end{bmatrix},
\end{gather}
\end{footnotesize}
where $H\left(\cdot\right)$ is the heaviside function and
\begin{gather*}
\pdfrac{\beta}{\kappa_t}=\left(1-\alpha\right)\dfrac{\bar{f}_c}{\bar{f}_t^2}\bar{f}_t',\\
\pdfrac{\beta}{\kappa_c}=\left(\alpha-1\right)\dfrac{1}{\bar{f}_t}\bar{f}_c'.
\end{gather*}
In the explicit form, if $\hat{\sigma}_1>0$,
\begin{footnotesize}
\begin{gather}
\mb{J}=\begin{bmatrix}
-9K\alpha\alpha_p-\sqrt{6}G-\beta\left(2G\hat{n}_1+3K\alpha_p\right)&(1-\alpha)\dfrac{\bar{f}_c\hat{\sigma}_1}{\bar{f}_t^2}\bar{f}_t'&\left(1-\alpha\right)\left(1-\dfrac{\hat{\sigma}_1}{\bar{f}_t}\right)\bar{f}_c'\\[4mm]
f_t\dfrac{\hat{n}_1+\alpha_p}{g_t}\left(r+\gamma\pdfrac{r}{\gamma}\right)&r\gamma\dfrac{\hat{n}_1+\alpha_p}{g_t}f_t'-1&\cdot\\[4mm]
f_c\dfrac{\hat{n}_3+\alpha_p}{g_c}\left(1-r-\gamma\pdfrac{r}{\gamma}\right)&\cdot&\left(1-r\right)\gamma\dfrac{\hat{n}_3+\alpha_p}{g_c}f_c'-1
\end{bmatrix},
\end{gather}
\end{footnotesize}
otherwise,
\begin{footnotesize}
\begin{gather}
\mb{J}=\begin{bmatrix}
-9K\alpha\alpha_p-\sqrt{6}G&\cdot&\left(1-\alpha\right)\bar{f}_c'\\[4mm]
f_t\dfrac{\hat{n}_1+\alpha_p}{g_t}\left(r+\gamma\pdfrac{r}{\gamma}\right)&r\gamma\dfrac{\hat{n}_1+\alpha_p}{g_t}f_t'-1&\cdot\\[4mm]
f_c\dfrac{\hat{n}_3+\alpha_p}{g_c}\left(1-r-\gamma\pdfrac{r}{\gamma}\right)&\cdot&\left(1-r\right)\gamma\dfrac{\hat{n}_3+\alpha_p}{g_c}f_c'-1
\end{bmatrix}.
\end{gather}
\end{footnotesize}
\subsection{Damage Formulation}
There is no local iteration required in the damage part. Once $\kappa_t$ and $\kappa_c$ are determined, the effective part $\bar\bsigma$ can be determined. Damage measures $d_t$ and $d_c$ can be computed accordingly.
\subsection{Consistent Tangent Stiffness}
In order to take derivatives with regard to trial strain, one can replace $\norm{\hat{\bs}^\text{trial}}$ and $\norm{\bar{\bs}^\text{trial}}$, which yields
\begin{gather}
\pdfrac{\mb{R}}{\bvarepsilon_{n+1}}=\left\{
\begin{array}{l}
3K\alpha{}\mb{1}+\sqrt{6}G\bn+H\left(\hat{\sigma}_1\right)\beta\ddfrac{\hat\sigma_1}{\bbsigma}:\pdfrac{\bbsigma}{\bvarepsilon_{n+1}},\\[4mm]
\gamma\dfrac{f_t}{g_t}\left(r\pdfrac{\hat{n}_1}{\bvarepsilon_{n+1}}+\left(\hat{n}_1+\alpha_p\right)\ddfrac{r}{\bbsigma}:\pdfrac{\bbsigma}{\bvarepsilon_{n+1}}\right),\\[4mm]
\gamma\dfrac{f_c}{g_c}\left(\left(1-r\right)\pdfrac{\hat{n}_3}{\bvarepsilon_{n+1}}-\left(\hat{n}_3+\alpha_p\right)\ddfrac{r}{\bbsigma}:\pdfrac{\bbsigma}{\bvarepsilon_{n+1}}\right).
\end{array}
\right.
\end{gather}
so that
\begin{gather}
\ddfrac{\mb{x}}{\bvarepsilon_{n+1}}=\begin{bmatrix}
\ddfrac{\gamma}{\bvarepsilon_{n+1}}\\[3mm]
\ddfrac{\kappa_t}{\bvarepsilon_{n+1}}\\[3mm]
\ddfrac{\kappa_c}{\bvarepsilon_{n+1}}
\end{bmatrix}=-\left(\pdfrac{\mb{R}}{\mb{x}}\right)^{-1}\pdfrac{\mb{R}}{\bvarepsilon_{n+1}}.
\end{gather}

The effective stress $\bbsigma_{n+1}$ only depends on $\bvarepsilon_{n+1}$ and $\gamma$. The partial derivative is
\begin{gather}
\begin{split}
\pdfrac{\bbsigma_{n+1}}{\bvarepsilon_{n+1}}&=\pdfrac{}{\bvarepsilon_{n+1}}\left(\bs^\text{trial}-2G\gamma\dfrac{\bs^\text{trial}}{\norm{\bs^\text{trial}}}+\left(p^\text{trial}-3K\alpha_p\gamma\right)\mb{1}\right)\\
&=\mb{D}-\dfrac{4G^2\gamma}{\norm{\bs^\text{trial}}}\left(\mathbb{I}^\text{dev}-\bn\otimes{}\bn\right).
\end{split}
\end{gather}
The full derivative is
\begin{gather}
\begin{split}
\ddfrac{\bbsigma_{n+1}}{\bvarepsilon_{n+1}}&=\ddfrac{}{\bvarepsilon_{n+1}}\left(\bs^\text{trial}-2G\gamma\dfrac{\bs^\text{trial}}{\norm{\bs^\text{trial}}}+\left(p^\text{trial}-3K\alpha_p\gamma\right)\mb{1}\right)\\
&=\mb{D}-\dfrac{4G^2\gamma}{\norm{\bs^\text{trial}}}\left(\mathbb{I}^\text{dev}-\bn\otimes{}\bn\right)-\left(2G\bn+3K\alpha_p\mb{1}\right)\otimes\pdfrac{\gamma}{\bvarepsilon_{n+1}}\\
&=\pdfrac{\bbsigma_{n+1}}{\bvarepsilon_{n+1}}-\left(2G\bn+3K\alpha_p\mb{1}\right)\otimes\pdfrac{\gamma}{\bvarepsilon_{n+1}}.
\end{split}
\end{gather}

The derivative of the damage factor can be expressed as
\begin{gather}
\begin{split}
\ddfrac{h}{\bvarepsilon_{n+1}}&=\left(1-d_c\right)\ddfrac{\left(1-sd_t\right)}{\bvarepsilon_{n+1}}+\left(1-sd_t\right)\ddfrac{\left(1-d_c\right)}{\bvarepsilon_{n+1}}\\
&=\left(d_c-1\right)\left(s\ddfrac{d_t}{\bvarepsilon_{n+1}}+d_t\ddfrac{s}{\bvarepsilon_{n+1}}\right)+\left(sd_t-1\right)\ddfrac{d_c}{\bvarepsilon_{n+1}},
\end{split}
\end{gather}
with
\begin{gather}
\ddfrac{d_t}{\bvarepsilon_{n+1}}=\ddfrac{d_t}{\kappa_t}\ddfrac{\kappa_t}{\bvarepsilon_{n+1}},\\
\ddfrac{d_c}{\bvarepsilon_{n+1}}=\ddfrac{d_c}{\kappa_c}\ddfrac{\kappa_c}{\bvarepsilon_{n+1}},\\
\ddfrac{s}{\bvarepsilon_{n+1}}=\left(1-s_0\right)\ddfrac{r}{\bbsigma_{n+1}}:\ddfrac{\bbsigma_{n+1}}{\bvarepsilon_{n+1}}.
\end{gather}

The following derivatives would be useful.
\begin{gather}
\ddfrac{d_\aleph}{\kappa_\aleph}=\dfrac{c_\aleph}{b_\aleph}\dfrac{a_\aleph+2}{2\sqrt{\phi_\aleph}}\Phi_\aleph^{c_\aleph/b_\aleph-1},\\
\ddfrac{f_\aleph}{\kappa_\aleph}=f_{\aleph,0}\dfrac{a_\aleph+2}{2\sqrt{\phi_\aleph}}\left(a_\aleph-2\sqrt{\phi_\aleph}+1\right),\\
\ddfrac{\bar{f}_\aleph}{\kappa_\aleph}=f_{\aleph,0}\dfrac{a_\aleph+2}{2\sqrt{\phi_\aleph}}\dfrac{\left(a_\aleph+1+\left(\dfrac{c_\aleph}{b_\aleph}-2\right)\sqrt{\phi_\aleph}\right)}{\Phi_\aleph^{c_\aleph/b_\aleph}}.
\end{gather}

Given that the stress update is computed as follows,
\begin{gather}
\bsigma_{n+1}=h\bbsigma_{n+1},
\end{gather}
the consistent tangent stiffness is then
\begin{gather}
\begin{split}
\ddfrac{\bsigma_{n+1}}{\bvarepsilon_{n+1}}&=\bbsigma_{n+1}\otimes\ddfrac{h}{\bvarepsilon_{n+1}}+h\ddfrac{\bbsigma_{n+1}}{\bvarepsilon_{n+1}}\\
&=\bbsigma_{n+1}\otimes\left(\left(d_c-1\right)\left(s\ddfrac{d_t}{\bvarepsilon_{n+1}}+d_t\ddfrac{s}{\bvarepsilon_{n+1}}\right)+\left(sd_t-1\right)\ddfrac{d_c}{\bvarepsilon_{n+1}}\right)+h\ddfrac{\bbsigma_{n+1}}{\bvarepsilon_{n+1}},
\end{split}
\end{gather}
which is equivalently,
\begin{multline}\label{eq:cdp_pd}
\ddfrac{\bsigma_{n+1}}{\bvarepsilon_{n+1}}=\bbsigma_{n+1}\otimes\underbrace{\left(\begin{bmatrix}
s\left(d_c-1\right)\ddfrac{d_t}{\kappa_t}&
\left(sd_t-1\right)\ddfrac{d_c}{\kappa_c}
\end{bmatrix}
\begin{bmatrix}
\ddfrac{\kappa_t}{\bvarepsilon_{n+1}}\\[4mm]
\ddfrac{\kappa_c}{\bvarepsilon_{n+1}}
\end{bmatrix}\right)}_\text{dot product in vector representation}\\+\left(d_t\left(d_c-1\right)\left(1-s_0\right)\bbsigma_{n+1}\otimes\ddfrac{r}{\bbsigma_{n+1}}+h\mathbb{I}\right)\ddfrac{\bbsigma_{n+1}}{\bvarepsilon_{n+1}}.
\end{multline}

The CDP model has no kinematic hardening, the effective part resembles the bounding surface concept. Due to the coaxiality, the model can be constructed in the eigen space, which brings some convenience in terms of implementation.
\subsection{Implementation}
The state determination of the CDP model is shown in \algoref{algo:cdp_model}. Compared with the original implementation, the presented one is much more concise and is able to avoid lengthy computation of consistent tangent stiffness.

It is worth noting some quantities remain constant in the local iteration, for example,
\begin{gather}
2G\hat{n}_1+3K\alpha_p,\qquad
\dfrac{\hat{n}_1+\alpha_p}{g_t},\qquad
\dfrac{\hat{n}_3+\alpha_p}{g_c}.
\end{gather}
They can be computed as stored before entering local iteration.
\begin{breakablealgorithm}
\caption{state determination of the CDP model}\label{algo:cdp_model}
\begin{algorithmic}
\State \textbf{Parameter}: $\lambda$, $G$
\State \textbf{Input}: $\bvarepsilon_{n+1}$, $\bvarepsilon_n$, $\bvarepsilon^p_n$, $\bsigma_n$, $\kappa_{\aleph,n}$
\State \textbf{Output}: $\mb{D}_{n+1}$, $\bvarepsilon^p_{n+1}$, $\bsigma_{n+1}$, $\kappa_{\aleph,n+1}$
\State $\bbsigma^\text{trial}=\mb{D}:\left(\bvarepsilon_{n+1}-\bvarepsilon^p_n\right)$
\State $\bs^\text{trial}=\dev{\bbsigma^\text{trial}}$
\State perform eigenanalysis on $\bbsigma^\text{trial}$ and compute $\mb{T}$, $\bar{\bs}^\text{trial}$
\State $\hat{\bn}=\dfrac{\bar{\bs}^\text{trial}}{\norm{\bar{\bs}^\text{trial}}}$
\State compute $f^\text{trial}$\Comment{\eqsref{eq:cdp_tf}}
\State $\kappa_{\aleph,n+1}=\kappa_{\aleph,n}$
\If {$f^\text{trial}\geqslant0$}\Comment{plasticity evolution}
\State compute $f_\aleph$, $\bar{f}_\aleph$ and $d_\aleph$ and their derivatives\Comment{This can be an independent overridable method.}
\While{true}
\State $\gamma=0$
\State compute $\mb{R}$ and $\pdfrac{\mb{R}}{\mb{x}}$\Comment{\eqsref{eq:cdp_r} and \eqsref{eq:cdp_dr}}
\State $\Delta=\left(\pdfrac{\mb{R}}{\mb{x}}\right)^{-1}\mb{R}$\Comment{$\Delta=\begin{bmatrix}
\delta\gamma&\delta\kappa_t&\delta\kappa_c
\end{bmatrix}$}
\If {$\norm{\Delta}<\text{tolerance}$}
\State break
\EndIf
\State $\gamma\leftarrow\gamma-\delta\gamma$
\State $\kappa_{t,n+1}\leftarrow\kappa_{t,n+1}-\delta\kappa_t$
\State $\kappa_{t,n+1}\leftarrow\kappa_{t,n+1}-\delta\kappa_c$
\EndWhile
\State $\bsigma_{n+1}=\bsigma^\text{trial}-\gamma\left(2G\bn+3K\alpha_p\mb{1}\right)$
\State $\bvarepsilon^p_{n+1}=\bvarepsilon^p_n+\gamma\left(\bn+\alpha_p\mb{1}\right)$
\State compute $\mb{D}_{n+1}$\Comment{\eqsref{eq:cdp_pd}}
\Else\Comment{elastic loading/unloading}
\State $\bsigma_{n+1}=\bsigma^\text{trial}$
\State $\bvarepsilon^p_{n+1}=\bvarepsilon^p_n$
\State compute $\mb{D}_{n+1}$\Comment{\eqsref{eq:cdp_ed}}
\EndIf
\end{algorithmic}
\end{breakablealgorithm}

The CPP implementation of state determination can be found as follows.
\begin{cppcode}
int NonlinearCDP::update_trial_status(const vec& t_strain) {
	incre_strain = (trial_strain = t_strain) - current_strain;

	if(norm(incre_strain) <= datum::eps) return SUANPAN_SUCCESS;

	trial_history = current_history;
	auto& d_t = trial_history(0);
	auto& d_c = trial_history(1);
	auto& kappa_t = trial_history(2);
	auto& kappa_c = trial_history(3);
	vec plastic_strain(&trial_history(4), 6, false, true);

	const auto& current_kappa_t = current_history(2);
	const auto& current_kappa_c = current_history(3);

	trial_stress = (trial_stiffness = initial_stiffness) * (trial_strain - plastic_strain); // 6

	vec principal_stress;    // 3
	mat principal_direction; // 3x3
	if(!eig_sym(principal_stress, principal_direction, tensor::stress::to_tensor(trial_stress), "std")) return SUANPAN_FAIL;

	const auto trans = transform::compute_jacobian_nominal_to_principal(principal_direction);

	const auto s = tensor::dev(trial_stress);    // 6
	const auto norm_s = tensor::stress::norm(s); // 1
	vec n = s / norm_s;                          // 6
	if(!n.is_finite()) n.zeros();

	const auto ps = tensor::dev(principal_stress); // 3
	const vec pn = normalise(ps);                  // 3

	const vec dsigmadlambda = -double_shear * pn - three_alpha_p_bulk; // 6

	const auto dgdsigma_t = (pn(2) + alpha_p) / g_t;
	const auto dgdsigma_c = (pn(0) + alpha_p) / g_c;

	auto new_stress = principal_stress;     // converged principal stress
	const auto& max_stress = new_stress(2); // algebraically maximum principal stress

	const auto const_yield = alpha * accu(principal_stress) + root_three_two * norm_s;

	vec residual(3), incre;
	mat jacobian(3, 3, fill::zeros);
	mat left(3, 6);

	podarray<double> t_para, c_para;

	auto lambda = 0., ref_error = 0.;
	double r, beta;
	vec dr;

	unsigned counter = 0;
	while(true) {
		if(max_iteration == ++counter) {
			suanpan_error("NonlinearCDP cannot converge within %u iterations.\n", max_iteration);
			return SUANPAN_FAIL;
		}

		t_para = compute_tension_backbone(kappa_t);
		c_para = compute_compression_backbone(kappa_c);

		const auto tension_flag = max_stress > 0.;

		beta = -one_minus_alpha * c_para(2) / t_para(2) - alpha - 1.;

		residual(0) = const_yield + pfplambda * lambda + one_minus_alpha * c_para(2);

		if(tension_flag) residual(0) += beta * max_stress;

		r = compute_r(new_stress);

		if(1 == counter && residual(0) < 0.) {
			const auto damage_c = scale * d_c - 1.;
			const auto damage_t = compute_s(r) * scale * d_t - 1.;
			const auto damage = damage_c * damage_t;
			trial_stiffness = (damage * eye(6, 6) + damage_c * scale * d_t * (1. - s0) * trial_stress * compute_dr(new_stress).t() * trans) * initial_stiffness;
			trial_stress *= damage;
			return SUANPAN_SUCCESS;
		}

		const auto t_term = t_para(1) * dgdsigma_t;
		const auto c_term = c_para(1) * dgdsigma_c;

		residual(1) = r * t_term * lambda + current_kappa_t - kappa_t;
		residual(2) = (c_term - r * c_term) * lambda + current_kappa_c - kappa_c;

		if(tension_flag) {
			jacobian(0, 0) = pfplambda + beta * dsigmadlambda(2);
			const auto tmp_term = one_minus_alpha * max_stress / t_para(2);
			jacobian(0, 1) = tmp_term * c_para(2) / t_para(2) * t_para(5);
			jacobian(0, 2) = (one_minus_alpha - tmp_term) * c_para(5);
		}
		else {
			jacobian(0, 0) = pfplambda;
			jacobian(0, 1) = 0.;
			jacobian(0, 2) = one_minus_alpha * c_para(5);
		}

		const auto dlambda = r + lambda * dot(dr = compute_dr(new_stress), dsigmadlambda);
		jacobian(1, 0) = t_term * dlambda;
		jacobian(2, 0) = c_term - c_term * dlambda;
		jacobian(1, 1) = r * lambda * dgdsigma_t * t_para(4) - 1.;
		jacobian(2, 2) = (lambda - r * lambda) * dgdsigma_c * c_para(4) - 1.;

		if(!solve(incre, jacobian, residual)) return SUANPAN_FAIL;

		auto error = norm(residual);
		if(1 == counter) ref_error = std::max(1., error);
		suanpan_debug("NonlinearCDP local iteration error: %.5E.\n", error /= ref_error);
		if(error <= tolerance || norm(incre) <= tolerance) break;

		lambda -= incre(0);
		kappa_t -= incre(1);
		kappa_c -= incre(2);
		new_stress -= dsigmadlambda * incre(0);

		if(kappa_t > 1.) kappa_t = .999; // avoid overshoot
		if(kappa_c > 1.) kappa_c = .999; // avoid overshoot
	}

	// update damage indices
	d_t = t_para(0);
	d_c = c_para(0);
	// update plastic strain
	plastic_strain += lambda * (n % tensor::stress::norm_weight + unit_alpha_p);

	const auto recovery = compute_s(r);
	const auto damage_c = scale * d_c - 1.;
	const auto damage_t = recovery * scale * d_t - 1.;
	const auto damage = damage_c * damage_t;

	// update trial stress
	trial_stress = transform::compute_jacobian_principal_to_nominal(principal_direction) * new_stress;

	const mat dnde = double_shear / norm_s * (unit_dev_tensor - n * n.t());

	// \dfrac{\partial\bar{\sigma}}{\partial\varepsilon^{tr}}
	trial_stiffness -= double_shear * lambda * dnde;

	const rowvec drdsigma = dr.t() * trans;
	const rowvec prpe = drdsigma * trial_stiffness;

	// compute local derivatives
	left.row(0) = 3. * alpha * bulk * tensor::unit_tensor2.t() + root_three_two * double_shear * n.t();
	left.row(1) = t_para(1) * lambda * (r / g_t * trans.row(2) * dnde + dgdsigma_t * prpe);
	left.row(2) = c_para(1) * lambda * ((1. - r) / g_c * trans.row(0) * dnde - dgdsigma_c * prpe);

	if(max_stress > 0.) left.row(0) += beta * trans.row(2) * trial_stiffness;

	const mat right = -solve(jacobian, left);
	const auto& dlambdade = right.row(0);
	const auto& dkappade = right.rows(1, 2);

	// \dfrac{\mathrm{d}\bar{\sigma}}{\mathrm{d}\varepsilon^{tr}}
	trial_stiffness -= (double_shear * n + three_alpha_p_bulk * tensor::unit_tensor2) * dlambdade;

	trial_stiffness = (damage * eye(6, 6) + scale * d_t * damage_c * (1. - s0) * trial_stress * drdsigma) * trial_stiffness + trial_stress * scale * rowvec{recovery * damage_c * t_para(3), damage_t * c_para(3)} * dkappade;

	trial_stress *= damage;

	return SUANPAN_SUCCESS;
}
\end{cppcode}
\section{CDPM2 Model}
The CDP adopts an isotropic damage, which leads to, for example, degradation of compressive/tensile strength due to tensile/compressive damage. In cyclic loading cases, it may not be ideal. The CDPM2 model uses a different approach that applies tensile damage to tensile part of stress and compressive damage to compressive part of stress.

Compared to the original formulation \cite{Grassl2013}, here the dependency of the Lode angle is removed for brevity.
\subsection{Plasticity}
The model is driven by the norm of the deviatoric stress $s=\norm{\mb{s}}$, the hydrostatic stress $p$ and the internal  hardening variable $\kappa_p$.
\subsubsection{Yield Function}
The yield function $F$ is defined as
\begin{gather}
F=g_1^2+m_0q^2_{h1}q_{h2}g_3-q^2_{h1}q^2_{h2},
\end{gather}
where the friction parameter $m_0$
\begin{gather}
m_0=\dfrac{3f_c^2-3f_t^2}{f_cf_t}\dfrac{e}{1+e}
\end{gather}
depends on material strengths $f_c$ and $f_t$, $e$ is the eccentricity constant which depends on the previous two strengths and equibiaxial compression strength $f_{bc}$. The hardening functions $q_{h1}$ and $q_{h2}$ will be introduced later. The helper functions $g_1$ and $g_3$ are also used to define the plastic potential $G$. If the Lode angle shall be considered, $g_3$ needs to be replaced by $g_4$ which is defined as
\begin{gather}
g_4=\dfrac{s}{\sqrt{6}f_c}r+\dfrac{p}{f_c},
\end{gather}
with $r=r\left(\theta\right)$ being a function of the lode angle $\theta$.

The partial derivatives of $F$ are
\begin{gather}
\pdfrac{F}{p}=2g_1\pdfrac{g_1}{p}+m_0q^2_{h1}q_{h2}\pdfrac{g_3}{p},\\
\pdfrac{F}{s}=2g_1\pdfrac{g_1}{s}+m_0q^2_{h1}q_{h2}\pdfrac{g_3}{s},\\
\pdfrac{F}{\kappa_p}=2g_1\pdfrac{g_1}{\kappa_p}+2m_0q_{h1}q_{h2}g_3\ddfrac{q_{h1}}{\kappa_p}+m_0q^2_{h1}g_3\ddfrac{q_{h2}}{\kappa_p}-2q_{h1}q_{h2}\left(q_{h2}\ddfrac{q_{h1}}{\kappa_p}+q_{h1}\ddfrac{q_{h2}}{\kappa_p}\right).
\end{gather}
\subsubsection{Flow Rule}
The plastic potential $G$ is defined as
\begin{gather}
G=g_1^2+q^2_{h1}g_2,
\end{gather}
where
\begin{gather}
g_1=\left(1-q_{h1}\right)g_3^2+\sqrt{\dfrac{3}{2}}\dfrac{s}{f_c},\qquad
g_2=\dfrac{m_0s}{\sqrt{6}f_c}+\dfrac{m_g}{f_c},\qquad
g_3=\dfrac{s}{\sqrt{6}f_c}+\dfrac{p}{f_c},\\
m_g=A_gB_gf_c\exp\left(\dfrac{3p-q_{h2}f_t}{3B_gf_c}\right),\\
A_g=\dfrac{3f_tq_{h2}}{f_c}+\dfrac{m_0}{2},\\
B_g=\dfrac{q_{h2}\left(1+f_t/f_c\right)/3}{\ln{}A_g-\ln\left(2D_f-1\right)-\ln\left(3q_{h2}+m_0/2\right)+\ln\left(D_f+1\right)}.
\end{gather}
With the derivatives of auxiliary functions expressed as
\begin{gather}
\pdfrac{g_3}{p}=\dfrac{1}{f_c},\qquad\pdfrac{g_3}{s}=\dfrac{1}{\sqrt{6}f_c},\qquad
\pdfrac{g_2}{p}=\dfrac{1}{f_c}\pdfrac{m_g}{p},\qquad\pdfrac{g_2}{s}=\dfrac{m_0}{\sqrt{6}f_c},\\
\pdfrac{g_1}{p}=2\left(1-q_{h1}\right)g_3\pdfrac{g_3}{p},\qquad\pdfrac{g_1}{s}=2\left(1-q_{h1}\right)g_3\pdfrac{g_3}{s}+\sqrt{\dfrac{3}{2}}\dfrac{1}{f_c}.
\end{gather}
The flow rule can be derived as
\begin{gather}
G_p=\pdfrac{G}{p}=2g_1\pdfrac{g_1}{p}+q^2_{h1}\pdfrac{g_2}{p}=\dfrac{4\left(1-q_{h1}\right)g_1g_3+q^2_{h1}A_g\exp\left(\dfrac{p-q_{h2}f_t/3}{B_gf_c}\right)}{f_c},\\
G_s=\pdfrac{G}{s}=2g_1\pdfrac{g_1}{s}+q^2_{h1}\pdfrac{g_2}{s}=\dfrac{4\left(1-q_{h1}\right)g_1g_3+6g_1+m_0q^2_{h1}}{\sqrt{6}f_c}.
\end{gather}
\subsubsection{Hardening Law}
The variables $q_{h1}$ and $q_{h2}$ are functions of the hardening variable $\kappa_p$.
\begin{gather}
q_{h1}=\left\{
\begin{array}{ll}
q_{h0}+\left(1-q_{h0}\right)\left(\kappa_p^3-3\kappa_p^2+3\kappa_p\right)-H_p\left(\kappa_p^3-3\kappa_p^2+2\kappa_p\right)&\text{for~}\kappa_p<1,\\
1&\text{for~}\kappa_p\geqslant1.
\end{array}
\right.\\
q_{h2}=\left\{
\begin{array}{ll}
1&\text{for~}\kappa_p<1,\\
1+H_p\left(\kappa_p-1\right)&\text{for~}\kappa_p\geqslant1.
\end{array}
\right.
\end{gather}

The evolution of $\kappa_p$ is defined as
\begin{gather}
\dot{\kappa_p}=\dfrac{\norm{\dot{\varepsilon_{p}}}}{x_h}4\cos^2\left(\theta\right).
\end{gather}
Here the dependency on the Lode angle $\theta$ is removed such that
\begin{gather}
x_h\dot{\kappa_p}=\norm{\dot{\varepsilon_{p}}}=\gamma{}G_\kappa,
\end{gather}
with $G_\kappa=\sqrt{G_s^2+G_p^2/3}$. This effectively means $\theta=2\pi/3$ is a constant.
\subsubsection{Plasticity Residual}
Collecting the yield function, evolutions of $s$, $p$ and $\kappa_p$, the local residual of the plasticity part can be expressed as
\begin{gather}
\mb{R}=\left\{
\begin{array}{l}
g_1^2+m_0q^2_{h1}q_{h2}g_3-q^2_{h1}q^2_{h2},\\[4mm]
s+2G\gamma{}G_s-s^\text{trial},\\[4mm]
p+K\gamma{}G_p-p^\text{trial},\\[4mm]
x_h\kappa_p^n+\gamma{}G_\kappa-x_h\kappa_p.
\end{array}
\right.
\end{gather}
The local system consists of four scalar equations.

The Jacobian thus has a size of \num{4} and reads
\begin{gather}
\mb{J}=\begin{bmatrix}
\cdot&\pdfrac{F}{s}&\pdfrac{F}{p}&\pdfrac{F}{\kappa_p}\\[6mm]
2GG_s&1+2G\gamma\pdfrac{G_s}{s}&2G\gamma\pdfrac{G_s}{p}&2G\gamma\pdfrac{G_s}{\kappa_p}\\[6mm]
KG_p&K\gamma\pdfrac{G_p}{s}&1+K\gamma\pdfrac{G_p}{p}&K\gamma\pdfrac{G_p}{\kappa_p}\\[6mm]
G_\kappa&\gamma\pdfrac{G_\kappa}{s}&\left(\kappa_p^n-\kappa_p\right)\ddfrac{x_h}{p}+\gamma\pdfrac{G_\kappa}{p}&\gamma\pdfrac{G_\kappa}{\kappa_p}-x_h
\end{bmatrix}.
\end{gather}
\subsection{Damage}
\subsubsection{Equivalent Strain}
The equivalent strain is defined as
\begin{gather}
\tilde{\varepsilon}=g_5+\sqrt{g_5^2+g_6^2},
\end{gather}
with
\begin{gather}
g_5=\dfrac{\varepsilon_0m_0}{2}g_3,\qquad
g_6=\sqrt{\dfrac{3}{2}}\dfrac{s}{f_c}.
\end{gather}
Again, if the Lode angle needs to be considered, replace $g_3$ with $g_4$. The equivalent strain is further split into tensile and compressive parts.
\begin{gather}
\tilde{\varepsilon}_t=\alpha_t\tilde{\varepsilon},\qquad
\tilde{\varepsilon}_c=\alpha_c\tilde{\varepsilon},
\end{gather}
where $\alpha_t+\alpha_c=1$ are two parameters that characterise the tensile/compressive portion of the current loading step.

The damage history variables $\kappa_{dt}$ and $\kappa_{dc}$ track the maximum values of $\tilde{\varepsilon}_t$ and $\tilde{\varepsilon}_c$, respectively.
\subsubsection{Tension}
The inelastic strain is expressed as a function of damage factors.
\begin{gather}
\varepsilon_i=\kappa_{dt1}+\omega_t\kappa_{dt2}.
\end{gather}
While the uniaxial stress response can be expressed as
\begin{gather}
\sigma=\left(1-\omega_t\right)E\kappa_{dt}.
\end{gather}
Assume an exponential degradation curve,
\begin{gather}
\sigma=f_t\exp\left(-\dfrac{\varepsilon_i}{\varepsilon_{ft}}\right)
\end{gather}

The local residual is
\begin{gather}
R=f_t\exp\left(-\dfrac{\varepsilon_i}{\varepsilon_{ft}}\right)-\left(1-\omega_t\right)E\kappa_{dt}.
\end{gather}
For a given set of $\kappa_{dt}$, $\kappa_{dt1}$ and $\kappa_{dt2}$, the above residual is a function of unknown $\omega_t$. It can be solved by, for example, Newton's method.
The corresponding derivatives are
\begin{gather}
\pdfrac{R}{\omega_t}=E\kappa_{dt}-\dfrac{\kappa_{dt2}}{\varepsilon_{fc}}f_t\exp\left(-\dfrac{\varepsilon_i}{\varepsilon_{ft}}\right),\\
\pdfrac{R}{\kappa_{dt}}=-\left(1-\omega_t\right)E,\\
\pdfrac{R}{\kappa_{dt1}}=-\dfrac{1}{\varepsilon_{ft}}f_t\exp\left(-\dfrac{\varepsilon_i}{\varepsilon_{ft}}\right),\\
\pdfrac{R}{\kappa_{dt2}}=-\dfrac{\omega_t}{\varepsilon_{ft}}f_t\exp\left(-\dfrac{\varepsilon_i}{\varepsilon_{ft}}\right).
\end{gather}
\subsubsection{Compression}
For compression, the definition fully resembles its tensile counterpart. The inelastic strain is driven by two internal parameters $\kappa_{dc1}$ and $\kappa_{dc2}$,
\begin{gather}
\varepsilon_i=\kappa_{dc1}+\omega_c\kappa_{dc2}.
\end{gather}
The uniaxial response is
\begin{gather}
\sigma=\left(1-\omega_c\right)E\kappa_{dc}.
\end{gather}
With the exponential backbone, the local residual is
\begin{gather}
R=f_t\exp\left(-\dfrac{\varepsilon_i}{\varepsilon_{fc}}\right)-\left(1-\omega_c\right)E\kappa_{dc}.
\end{gather}
\subsubsection{Stress}
The final stress can be expressed as
\begin{gather}
\bsigma=\left(1-\omega_t\right)\left(1-\omega_c\right)\bbsigma.
\end{gather}
This form is identical to the one used in the CDP model. It represents the isotropic damage.
Alternatively, it can also be expressed as
\begin{gather}\label{eq:aniso_damage}
\bsigma=\left(1-\omega_t\right)\bbsigma_t+\left(1-\omega_c\right)\bbsigma_c,
\end{gather}
which stands for the anisotropic damage. The tensile and compressive part of the stress tensor $\bbsigma_t$ and $\bbsigma_c$ are obtained by performing an eigenanalysis such that
\begin{gather}
\bbsigma_t=\sum_{i=1}^3\left\langle\hat{\sigma}_i\right\rangle\mb{p}_i\otimes\mb{p}_i,\qquad\bbsigma_c=\bbsigma-\bbsigma_t,
\end{gather}
where $\hat{\sigma}_i$ is the eigenvalue of $\bbsigma$ and $\mb{p}_i$ is the associated eigenvector.

\eqsref{eq:aniso_damage} can be equivalently expressed as
\begin{gather}
\begin{split}
\bsigma&=\left(1-\omega_t\right)\bbsigma_t+\left(1-\omega_c\right)\left(\bbsigma-\bbsigma_t\right)\\
&=\left(1-\omega_c\right)\bbsigma+\left(\omega_c-\omega_t\right)\bbsigma_t.
\end{split}
\end{gather}
With the above expression, the tangent stiffness can be expressed as
\begin{gather}
\ddfrac{\bsigma}{\bvarepsilon}=\left(1-\omega_c\right)\ddfrac{\bbsigma}{\bvarepsilon}+\left(\omega_c-\omega_t\right)\ddfrac{\bbsigma_t}{\bbsigma}\ddfrac{\bbsigma}{\bvarepsilon}-\bbsigma\otimes\ddfrac{\omega_c}{\bvarepsilon}+\bbsigma_t\otimes\left(\ddfrac{\omega_c}{\bvarepsilon}-\ddfrac{\omega_t}{\bvarepsilon}\right).
\end{gather}
\subsection{Formulation}
\subsection{Implementation}
The main body of state determination consists of two main tasks: 1) compute the plasticity part and 2) compute the damage part. The implementation can be found as follows.
\begin{cppcode}
int CDPM2::update_trial_status(const vec& t_strain) {
	incre_strain = (trial_strain = t_strain) - current_strain;

	if(norm(incre_strain) <= tolerance) return SUANPAN_SUCCESS;

	trial_history = current_history;
	const auto& current_kp = current_history(0);
	auto& kp = trial_history(0);
	vec plastic_strain(&trial_history(1), 6, false, true);

	trial_stress = (trial_stiffness = initial_stiffness) * (trial_strain - plastic_strain);

	//
	// plasticity part
	//

	const auto dev_stress = tensor::dev(trial_stress);
	const auto hydro_stress = tensor::mean3(trial_stress);
	const auto trial_s = tensor::stress::norm(dev_stress);
	const auto trial_p = hydro_stress;
	const vec n = dev_stress / trial_s;

	auto gamma = 0., s = trial_s, p = trial_p;

	mat jacobian(4, 4, fill::none), left(4, 6, fill::zeros);
	jacobian(0, 0) = 0.;

	vec residual(4), incre;

	podarray<double> data(15);
	const auto& f = data(0);
	const auto& pfps = data(1);
	const auto& pfpp = data(2);
	const auto& pfpkp = data(3);
	const auto& gs = data(4);
	const auto& gp = data(5);
	const auto& gg = data(6);
	const auto& pgsps = data(7);
	const auto& pgspp = data(8);
	const auto& pgspkp = data(9);
	const auto& pgpps = data(10);
	const auto& pgppp = data(11);
	const auto& pgppkp = data(12);
	const auto& xh = data(13);
	const auto& dxhdp = data(14);

	auto counter = 0u;

	while(true) {
		if(max_iteration == ++counter) return SUANPAN_FAIL;

		compute_plasticity(s, p, kp, data);

		if(1 == counter && f < 0.) break;

		residual(0) = f;
		residual(1) = s + double_shear * gamma * gs - trial_s;
		residual(2) = p + bulk * gamma * gp - trial_p;
		residual(3) = xh * (current_kp - kp) + gamma * gg;

		jacobian(0, 1) = pfps;
		jacobian(0, 2) = pfpp;
		jacobian(0, 3) = pfpkp;

		jacobian(1, 0) = double_shear * gs;
		jacobian(1, 1) = double_shear * gamma * pgsps + 1.;
		jacobian(1, 2) = double_shear * gamma * pgspp;
		jacobian(1, 3) = double_shear * gamma * pgspkp;

		jacobian(2, 0) = bulk * gp;
		jacobian(2, 1) = bulk * gamma * pgpps;
		jacobian(2, 2) = bulk * gamma * pgppp + 1.;
		jacobian(2, 3) = bulk * gamma * pgppkp;

		jacobian(3, 0) = gg;
		jacobian(3, 1) = gamma / gg * (gs * pgsps + gp / 3. * pgpps);
		jacobian(3, 2) = gamma / gg * (gs * pgspp + gp / 3. * pgppp) + (current_kp - kp) * dxhdp;
		jacobian(3, 3) = gamma / gg * (gs * pgspkp + gp / 3. * pgppkp) - xh;

		if(!solve(incre, jacobian, residual)) return SUANPAN_FAIL;

		const auto error = norm(residual);
		suanpan_debug("CDPM2 local plasticity iteration error: %.5E.\n", error);

		if(error <= tolerance) {
			const vec unit_n = n % tensor::stress::norm_weight;

			plastic_strain += gamma * gs * unit_n + gamma * gp / 3. * tensor::unit_tensor2;

			trial_stress = s * n + p * tensor::unit_tensor2;

			mat right(4, 6, fill::none);

			right.row(0).zeros();
			right.row(1) = double_shear * unit_n.t() * unit_dev_tensor;
			right.row(2) = bulk * tensor::unit_tensor2.t();
			right.row(3).zeros();

			if(!solve(left, jacobian, right)) return SUANPAN_FAIL;

			trial_stiffness = n * (left.row(1) - s / trial_s * right.row(1)) + s / trial_s * double_shear * unit_dev_tensor;
			trial_stiffness.row(0) += left.row(2);
			trial_stiffness.row(1) += left.row(2);
			trial_stiffness.row(2) += left.row(2);

			break;
		}

		gamma -= incre(0);
		s -= incre(1);
		p -= incre(2);
		kp -= incre(3);
	}

	//
	// damage part
	//

	vec principal_stress;    // 3
	mat principal_direction; // 3x3
	if(!eig_sym(principal_stress, principal_direction, tensor::stress::to_tensor(trial_stress), "std")) return SUANPAN_FAIL;

	vector<uword> tp, cp;
	tp.reserve(3);
	cp.reserve(3);
	for(auto I = 0llu; I < 3llu; ++I)
		if(principal_stress(I) > 0.) tp.emplace_back(I);
		else cp.emplace_back(I);

	const uvec t_pattern(tp), c_pattern(cp);

	const auto aca = accu(square(principal_stress(c_pattern)));
	const auto acb = accu(square(principal_stress));
	const auto ac = aca / acb;
	rowvec daca = 2. * principal_stress.t();
	daca(t_pattern).fill(0.);
	const rowvec dac = (daca - 2. * ac * principal_stress.t()) / acb;

	if(SUANPAN_SUCCESS != compute_damage(gamma, s, p, kp, ac, data)) return SUANPAN_FAIL;

	if(DamageType::NODAMAGE == damage_type) return SUANPAN_SUCCESS;

	const auto& omegat = trial_history(16);
	const auto& omegac = trial_history(17);
	const rowvec pot(&data(0), 4, false, true);
	const rowvec poc(&data(4), 4, false, true);
	const auto& pocpac = data(8);

	const rowvec potpe = pot * left;
	const rowvec pocpe = poc * left + pocpac * dac * transform::compute_jacobian_nominal_to_principal(principal_direction) * trial_stiffness;

	if(DamageType::ISOTROPIC == damage_type) {
		trial_stiffness *= (1. - omegat) * (1. - omegac);
		trial_stiffness -= trial_stress * ((1. - omegat) * pocpe + (1. - omegac) * potpe);

		trial_stress *= (1. - omegat) * (1. - omegac);
	}
	else if(DamageType::ANISOTROPIC == damage_type) {
		const auto compute_fraction = [&](const double a, const double b) { return suanpan::approx_equal(a, b, 4) ? a + b <= 0. ? 0. : 2. : 2. * (suanpan::ramp(a) - suanpan::ramp(b)) / (a - b); };
		const auto get_fraction = [&](const vec& p_stress) { return vec{compute_fraction(p_stress(0), p_stress(1)), compute_fraction(p_stress(1), p_stress(2)), compute_fraction(p_stress(2), p_stress(0))}; };

		const mat pnn = [](const mat& eig_vec) {
			const mat n12 = eig_vec.col(0) * eig_vec.col(1).t();
			const mat n23 = eig_vec.col(1) * eig_vec.col(2).t();
			const mat n31 = eig_vec.col(2) * eig_vec.col(0).t();

			mat pij(6, 6);

			pij.col(0) = tensor::stress::to_voigt(eig_vec.col(0) * eig_vec.col(0).t());
			pij.col(1) = tensor::stress::to_voigt(eig_vec.col(1) * eig_vec.col(1).t());
			pij.col(2) = tensor::stress::to_voigt(eig_vec.col(2) * eig_vec.col(2).t());
			pij.col(3) = tensor::stress::to_voigt(.5 * (n12 + n12.t()));
			pij.col(4) = tensor::stress::to_voigt(.5 * (n23 + n23.t()));
			pij.col(5) = tensor::stress::to_voigt(.5 * (n31 + n31.t()));

			return pij;
		}(principal_direction);

		mat tension_projector = pnn.cols(t_pattern) * pnn.cols(t_pattern).t();
		mat tension_derivative = tension_projector + pnn.tail_cols(3) * diagmat(get_fraction(principal_stress)) * pnn.tail_cols(3).t();

		tension_projector.tail_cols(3) *= 2.;
		tension_derivative.tail_cols(3) *= 2.;

		const vec tension_stress = tension_projector * trial_stress;

		trial_stiffness = (1. - omegac) * trial_stiffness - trial_stress * pocpe + (omegac - omegat) * tension_derivative * trial_stiffness + tension_stress * (pocpe - potpe);

		trial_stress *= 1. - omegac;
		trial_stress += (omegac - omegat) * tension_stress;
	}

	return SUANPAN_SUCCESS;
}
\end{cppcode}

Here, all relevant quantities (mainly derivatives) are stored in array \texttt{data} that is passed to the corresponding functions. For example, in order to compute plasticity, the following method is used. It is lengthy and tedious, mainly computing derivatives via the chain rule.
\begin{cppcode}
void CDPM2::compute_plasticity(const double s, const double p, const double kp, podarray<double>& data) const {
    auto& f = data(0);
    auto& pfps = data(1);
    auto& pfpp = data(2);
    auto& pfpkp = data(3);
    auto& gs = data(4);
    auto& gp = data(5);
    auto& gg = data(6);
    auto& pgsps = data(7);
    auto& pgspp = data(8);
    auto& pgspkp = data(9);
    auto& pgpps = data(10);
    auto& pgppp = data(11);
    auto& pgppkp = data(12);
    auto& xh = data(13);
    auto& dxhdp = data(14);

    auto qh1 = 1., qh2 = 1.;
    auto dqh1dkp = 0., dqh2dkp = 0.;

    if(kp < 1.) {
        qh1 = qh0 + (1. - qh0) * kp * (kp * (kp - 3.) + 3.) - hp * kp * (kp - 1.) * (kp - 2.);
        dqh1dkp = (3. - 3. * qh0) * pow(kp - 1., 2.) - hp * (3. * kp * (kp - 2.) + 2.);
    }
    else {
        qh2 = 1. + hp * (kp - 1.);
        dqh2dkp = hp;
    }

    const auto ag = 3. * ftfc * qh2 + .5 * m0;
    const auto dagdkp = 3. * ftfc * dqh2dkp;
    const auto cg = qh2 * (1. + ftfc) / 3.;
    const auto dg = log(ag) - log(3. * qh2 + .5 * m0) + lndf;
    const auto dcgdkp = dqh2dkp * (1. + ftfc) / 3.;
    const auto ddgdkp = dagdkp / ag - dqh2dkp / (qh2 + m0 / 6.);
    const auto bg = cg / dg;
    const auto dbgdkp = (dcgdkp - bg * ddgdkp) / dg;

    const auto eg = (p / fc - qh2 * ftfc / 3.) / bg;
    const auto pegpkp = (-ftfc / 3. * dqh2dkp - eg * dbgdkp) / bg;
    const auto pmgpp = ag * exp(eg);

    const auto g3 = (s / sqrt_six + p) / fc;
    const auto g1 = (1. - qh1) * g3 * g3 + sqrt_three_two * s / fc;

    const auto pg3pp = 1. / fc;
    const auto pg3ps = pg3pp / sqrt_six;

    const auto pg2pp = pmgpp / fc;
    const auto pg2ps = m0 * pg3ps;

    const auto pg1pp = (2. - 2. * qh1) * g3 * pg3pp;
    const auto pg1ps = (2. - 2. * qh1) * g3 * pg3ps + sqrt_three_two / fc;
    const auto pg1pkp = -dqh1dkp * g3 * g3;

    f = g1 * g1 + m0 * qh1 * qh1 * qh2 * g3 - qh1 * qh1 * qh2 * qh2;

    pfpp = 2. * g1 * pg1pp + m0 * qh1 * qh1 * qh2 * pg3pp;
    pfps = 2. * g1 * pg1ps + m0 * qh1 * qh1 * qh2 * pg3ps;
    pfpkp = 2. * g1 * pg1pkp + 2. * qh1 * qh2 * (m0 * g3 * dqh1dkp - qh1 * dqh2dkp - qh2 * dqh1dkp) + m0 * qh1 * qh1 * g3 * dqh2dkp;

    gp = 2. * g1 * pg1pp + qh1 * qh1 * pg2pp;
    gs = 2. * g1 * pg1ps + qh1 * qh1 * pg2ps;

    gg = sqrt(gs * gs + gp * gp / 3.);

    pgppp = (4. - 4. * qh1) * (pg1pp * g3 + g1 * pg3pp) + qh1 * qh1 * ag * exp(eg) / bg / fc;
    pgpps = (4. - 4. * qh1) * (pg1ps * g3 + g1 * pg3ps);
    pgppkp = 4. * g3 * (pg1pkp - qh1 * pg1pkp - dqh1dkp * g1) + (2. * dqh1dkp * ag + qh1 * (dagdkp + ag * pegpkp)) * qh1 * exp(eg);

    pgppp /= fc;
    pgpps /= fc;
    pgppkp /= fc;

    pgspp = (4. - 4. * qh1) * (pg1pp * g3 + g1 * pg3pp) + 6. * pg1pp;
    pgsps = (4. - 4. * qh1) * (pg1ps * g3 + g1 * pg3ps) + 6. * pg1ps;
    pgspkp = 4. * g3 * (pg1pkp - qh1 * pg1pkp - dqh1dkp * g1) + 6. * pg1pkp + 2. * m0 * qh1 * dqh1dkp;

    pgspp /= sqrt_six * fc;
    pgsps /= sqrt_six * fc;
    pgspkp /= sqrt_six * fc;

    if(const auto rh = -p / fc - 1. / 3.; rh >= 0.) {
        xh = (bh - ah) * exp(-rh / ch);
        dxhdp = xh / ch / fc;
        xh += ah;
    }
    else {
        xh = eh * exp(rh / fh);
        dxhdp = -xh / fh / fc;
        xh += dh;
    }
}
\end{cppcode}

The converged \texttt{data} is then passed to the method to compute damage factors. It is similar to the plasticity part.
\begin{cppcode}
int CDPM2::compute_damage(const double gamma, const double s, const double p, const double kp, const double ac, podarray<double>& data) {
    const auto& gs = data(4);
    const auto& gp = data(5);
    const auto& gg = data(6);
    const auto& pgsps = data(7);
    const auto& pgspp = data(8);
    const auto& pgspkp = data(9);
    const auto& pgpps = data(10);
    const auto& pgppp = data(11);
    const auto& pgppkp = data(12);

    const auto& current_ee = current_history(7);
    const auto& current_et = current_history(8);
    const auto& current_ec = current_history(9);
    const auto& current_kdt1 = current_history(12);
    const auto& current_kdc1 = current_history(13);
    const auto& current_kdt2 = current_history(14);
    const auto& current_kdc2 = current_history(15);
    auto& ee = trial_history(7);
    auto& et = trial_history(8);
    auto& ec = trial_history(9);
    auto& kdt = trial_history(10);
    auto& kdc = trial_history(11);
    auto& kdt1 = trial_history(12);
    auto& kdc1 = trial_history(13);
    auto& kdt2 = trial_history(14);
    auto& kdc2 = trial_history(15);
    auto& omegat = trial_history(16);
    auto& omegac = trial_history(17);

    // ee
    const auto ptapp = .5 * e0 * m0 / fc;
    const auto ptaps = ptapp / sqrt_six;
    const auto ptbps = sqrt_three_two * e0 / fc;
    const auto term_a = ptaps * s + ptapp * p;
    const auto term_b = ptbps * s;
    const auto term_c = sqrt(term_a * term_a + term_b * term_b);
    ee = term_a + term_c;
    const auto incre_ee = ee - current_ee;
    const auto peeps = (ptaps * ee + term_b * ptbps) / term_c;
    const auto peepp = ptapp * ee / term_c;

    // ep
    const auto ep = gamma * gg;
    const auto peppg = gg;
    const auto pepps = gamma / gg * (gs * pgsps + gp / 3. * pgpps);
    const auto peppp = gamma / gg * (gs * pgspp + gp / 3. * pgppp);
    const auto peppkp = gamma / gg * (gs * pgspkp + gp / 3. * pgppkp);

    // xs
    auto xs = 1., pxsps = 0., pxspp = 0.;
    if(p <= 0.) {
        pxspp = (sqrt_six - as * sqrt_six) / s;
        xs += pxspp * p;
        pxsps = -pxspp * p / s;
    }

    // kdt
    auto incre_kdt = 0., pkdtps = 0., pkdtpp = 0.;
    if((et = current_et + incre_ee) > kdt) {
        incre_kdt = et - kdt;
        kdt = et;
        pkdtps = peeps;
        pkdtpp = peepp;
    }

    // kdt1
    auto pkdt1pg = 0., pkdt1ps = 0., pkdt1pp = 0., pkdt1pkp = 0.;
    if(incre_kdt > 0. && kdt > e0) {
        const auto incre_kdt1 = ep / xs;
        kdt1 = current_kdt1 + incre_kdt1;
        pkdt1pg = peppg / xs;
        pkdt1ps = (pepps - incre_kdt1 * pxsps) / xs;
        pkdt1pp = (peppp - incre_kdt1 * pxspp) / xs;
        pkdt1pkp = peppkp / xs;
    }

    // kdt2
    const auto incre_kdt2 = incre_kdt / xs;
    kdt2 = current_kdt2 + incre_kdt2;
    const auto pkdt2ps = (pkdtps - incre_kdt2 * pxsps) / xs;
    const auto pkdt2pp = (pkdtpp - incre_kdt2 * pxspp) / xs;

    // kdc
    auto incre_kdc = 0., pkdcps = 0., pkdcpp = 0., pkdcpac = 0.;
    if((ec = current_ec + ac * incre_ee) > kdc) {
        incre_kdc = ec - kdc;
        kdc = ec;
        pkdcps = ac * peeps;
        pkdcpp = ac * peepp;
        pkdcpac = incre_ee;
    }

    // kdc1
    auto pkdc1pg = 0., pkdc1ps = 0., pkdc1pp = 0., pkdc1pkp = 0., pkdc1pac = 0.;
    if(incre_kdc > 0. && kdc > e0) {
        auto qh2 = 1., dqh2dkp = 0.;
        if(kp >= 1.) {
            qh2 += hp * kp - hp;
            dqh2dkp = hp;
        }

        const auto betac = sqrtdf * qh2 / s;
        const auto pbetacpkp = sqrtdf / s * dqh2dkp;
        const auto pbetacps = -betac / s;

        pkdc1pac = ep * betac / xs;
        const auto incre_kdc1 = pkdc1pac * ac;
        kdc1 = current_kdc1 + incre_kdc1;
        pkdc1pg = peppg * ac * betac / xs;
        pkdc1ps = ac / xs * (pepps * betac + ep * pbetacps - ep * betac / xs * pxsps);
        pkdc1pp = ac / xs * betac * (peppp - ep / xs * pxspp);
        pkdc1pkp = ac / xs * (peppkp * betac + ep * pbetacpkp);
    }

    // kdc2
    const auto incre_kdc2 = incre_kdc / xs;
    kdc2 = current_kdc2 + incre_kdc2;
    const auto pkdc2ps = (pkdcps - incre_kdc2 * pxsps) / xs;
    const auto pkdc2pp = (pkdcpp - incre_kdc2 * pxspp) / xs;
    const auto pkdc2pac = pkdcpac / xs;

    podarray<double> datad(3);

    if(SUANPAN_SUCCESS != compute_damage_factor(kdt, kdt1, kdt2, eft, omegat, datad)) return SUANPAN_FAIL;
    const auto& potpkdt = datad(0);
    const auto& potpkdt1 = datad(1);
    const auto& potpkdt2 = datad(2);

    auto& potpg = data(0);
    auto& potps = data(1);
    auto& potpq = data(2);
    auto& potpkp = data(3);

    potpg = potpkdt1 * pkdt1pg;
    potps = potpkdt * pkdtps + potpkdt1 * pkdt1ps + potpkdt2 * pkdt2ps;
    potpq = potpkdt * pkdtpp + potpkdt1 * pkdt1pp + potpkdt2 * pkdt2pp;
    potpkp = potpkdt1 * pkdt1pkp;

    if(SUANPAN_SUCCESS != compute_damage_factor(kdc, kdc1, kdc2, efc, omegac, datad)) return SUANPAN_FAIL;
    const auto& pocpkdc = datad(0);
    const auto& pocpkdc1 = datad(1);
    const auto& pocpkdc2 = datad(2);

    auto& pocpg = data(4);
    auto& pocps = data(5);
    auto& pocpq = data(6);
    auto& pocpkp = data(7);
    auto& pocpac = data(8);

    pocpg = pocpkdc1 * pkdc1pg;
    pocps = pocpkdc * pkdcps + pocpkdc1 * pkdc1ps + pocpkdc2 * pkdc2ps;
    pocpq = pocpkdc * pkdcpp + pocpkdc1 * pkdc1pp + pocpkdc2 * pkdc2pp;
    pocpkp = pocpkdc1 * pkdc1pkp;
    pocpac = pocpkdc * pkdcpac + pocpkdc1 * pkdc1pac + pocpkdc2 * pkdc2pac;

    return SUANPAN_SUCCESS;
}
\end{cppcode}

Finally, the damage part involves a local iteration procedure.
\begin{cppcode}
int CDPM2::compute_damage_factor(const double kd, const double kd1, const double kd2, const double ef, double& omega, podarray<double>& data) const {
    auto& popkd = data(0);
    auto& popkd1 = data(1);
    auto& popkd2 = data(2);

    if(kd < e0) {
        popkd = 0.;
        popkd1 = 0.;
        popkd2 = 0.;
        return SUANPAN_SUCCESS;
    }

    auto counter = 0u;
    while(true) {
        if(max_iteration == ++counter) return SUANPAN_FAIL;

        const auto term_a = ft * exp(-(kd1 + omega * kd2) / ef);
        const auto term_b = (1. - omega) * elastic_modulus;
        const auto jacobian = elastic_modulus * kd - kd2 / ef * term_a;
        const auto incre = (term_a - term_b * kd) / jacobian;

        const auto error = fabs(incre);
        suanpan_debug("Local damage iteration error: {:.5E}.\n", error);

        if(error <= tolerance) {
            popkd = term_b / jacobian;
            popkd1 = term_a / ef / jacobian;
            popkd2 = popkd1 * omega;
            return SUANPAN_SUCCESS;
        }

        omega -= incre;
    }
}
\end{cppcode}
